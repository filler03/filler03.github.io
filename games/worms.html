<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Slither Mobile</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        /* Force the body to be exactly the size of the iPhone screen */
        html, body {
            width: 100%;
            height: 100%;
            height: 100dvh;
            overflow: hidden;
            background: #0a0a1a;
            position: fixed;
            font-family: -apple-system, system-ui, sans-serif;
        }

        canvas {
            display: block;
            touch-action: none; /* Critical: Stops iOS from trying to scroll */
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1b1b3a 0%, #0a0a1a 100%);
        }

        /* Fixed UI Layer */
        #ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let touches pass through to the game */
            z-index: 10;
        }

        .label {
            position: absolute;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            font-family: monospace;
            padding: env(safe-area-inset-top) 15px;
        }

        #stats {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom));
            right: 20px;
            text-align: right;
            color: #00ffcc;
            font-family: monospace;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
        }

        #prompt {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            transition: opacity 0.5s;
        }

        #debug {
            position: absolute;
            bottom: 10px; left: 10px;
            color: red; font-size: 10px;
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div id="ui">
        <div class="label">SLITHER.IO MOBILE</div>
        <div id="prompt">
            <h1 style="margin-bottom:10px">READY?</h1>
            <p>Drag anywhere to move</p>
        </div>
        <div id="stats">
            <div id="stat-len">Length: 12</div>
            <div id="stat-pos">0, 0</div>
        </div>
        <div id="debug"></div>
    </div>

    <script>
    // Emergency logger for iPhone troubleshooting
    const debug = (msg) => { document.getElementById('debug').innerText += msg + " | "; };

    try {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const prompt = document.getElementById('prompt');
        const statLen = document.getElementById('stat-len');
        const statPos = document.getElementById('stat-pos');

        let width, height, dpr;
        let cameraX = 0, cameraY = 0;
        let targetX = 0, targetY = 0;
        let isMoving = false;

        function resize() {
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = Math.floor(width * dpr);
            canvas.height = Math.floor(height * dpr);
            ctx.scale(dpr, dpr);
            // On start, center the target
            if(!isMoving) { targetX = width/2; targetY = height/2; }
        }
        window.addEventListener('resize', resize);
        resize();

        // WORLD CONVERSION
        const toWorld = (sx, sy) => ({ x: sx - width/2 + cameraX, y: sy - height/2 + cameraY });
        const toScreen = (wx, wy) => ({ x: wx - cameraX + width/2, y: wy - cameraY + height/2 });

        // FOOD SYSTEM
        const foods = [];
        function spawnFood() {
            if (foods.length < 20) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 300 + Math.random() * 400;
                foods.push({
                    x: cameraX + Math.cos(angle) * dist,
                    y: cameraY + Math.sin(angle) * dist,
                    hue: Math.random() * 360
                });
            }
        }

        // WORM SYSTEM
        class Worm {
            constructor() {
                this.segments = [];
                this.radius = 12;
                this.angle = 0;
                this.speed = 3;
                for(let i=0; i<15; i++) {
                    this.segments.push({x: 0, y: 0});
                }
            }
            update() {
                const head = this.segments[0];
                const worldTarget = toWorld(targetX, targetY);
                
                const dx = worldTarget.x - head.x;
                const dy = worldTarget.y - head.y;
                const targetAngle = Math.atan2(dy, dx);
                
                // Smooth rotation
                let diff = targetAngle - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.angle += diff * 0.1;

                // Move head
                head.x += Math.cos(this.angle) * this.speed;
                head.y += Math.sin(this.angle) * this.speed;

                // Move body
                for(let i=1; i<this.segments.length; i++) {
                    const seg = this.segments[i];
                    const prev = this.segments[i-1];
                    const d = Math.hypot(prev.x - seg.x, prev.y - seg.y);
                    const minDist = 10;
                    if(d > minDist) {
                        const t = (d - minDist) / d;
                        seg.x += (prev.x - seg.x) * t;
                        seg.y += (prev.y - seg.y) * t;
                    }
                }
                cameraX = head.x;
                cameraY = head.y;
            }
            draw() {
                for(let i=this.segments.length-1; i>=0; i--) {
                    const pos = toScreen(this.segments[i].x, this.segments[i].y);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, i === 0 ? 14 : 11, 0, Math.PI*2);
                    ctx.fillStyle = i === 0 ? '#00ffcc' : `hsl(170, 100%, ${40 + (i*2)}%)`;
                    ctx.fill();
                    // Eyes
                    if(i === 0) {
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(pos.x + Math.cos(this.angle+0.5)*8, pos.y + Math.sin(this.angle+0.5)*8, 3, 0, Math.PI*2);
                        ctx.arc(pos.x + Math.cos(this.angle-0.5)*8, pos.y + Math.sin(this.angle-0.5)*8, 3, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            }
        }

        const player = new Worm();

        // INPUT HANDLING - Listening directly to window for maximum compatibility
        const input = (e) => {
            if(!isMoving) {
                isMoving = true;
                prompt.style.opacity = '0';
            }
            const t = e.touches ? e.touches[0] : e;
            targetX = t.clientX;
            targetY = t.clientY;
        };

        window.addEventListener('touchstart', (e) => { 
            // Only preventDefault if not touching a UI button (if added later)
            if(e.target === canvas) e.preventDefault(); 
            input(e); 
        }, {passive: false});

        window.addEventListener('touchmove', (e) => { 
            if(e.target === canvas) e.preventDefault(); 
            input(e); 
        }, {passive: false});

        window.addEventListener('mousemove', input);

        // GRID BACKGROUND
        function drawGrid() {
            const size = 100;
            const offsetX = -cameraX % size;
            const offsetY = -cameraY % size;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = offsetX; x < width; x += size) {
                ctx.moveTo(x, 0); ctx.lineTo(x, height);
            }
            for (let y = offsetY; y < height; y += size) {
                ctx.moveTo(0, y); ctx.lineTo(width, y);
            }
            ctx.stroke();
        }

        function loop() {
            // 1. Clear
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);

            // 2. Background
            drawGrid();

            // 3. Food
            spawnFood();
            foods.forEach((f, i) => {
                const pos = toScreen(f.x, f.y);
                ctx.fillStyle = `hsl(${f.hue}, 100%, 60%)`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, Math.PI*2);
                ctx.fill();

                // Eat detection
                if(Math.hypot(player.segments[0].x - f.x, player.segments[0].y - f.y) < 20) {
                    foods.splice(i, 1);
                    player.segments.push({ ...player.segments[player.segments.length-1] });
                }
            });

            // 4. Player
            player.update();
            player.draw();

            // 5. Stats
            statLen.innerText = `Length: ${player.segments.length}`;
            statPos.innerText = `${Math.round(player.segments[0].x)}, ${Math.round(player.segments[0].y)}`;

            requestAnimationFrame(loop);
        }

        loop();
        debug("Game initialized");

    } catch (err) {
        debug("Error: " + err.message);
    }
    </script>
</body>
</html>
